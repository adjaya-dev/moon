<?php

declare(strict_types=1);

namespace Moon\Core;

use Moon\Core\Collection\HttpPipelineArrayCollection;
use Moon\Core\Collection\HttpPipelineCollectionInterface;
use Moon\Core\Pipeline\HttpPipeline;

class Router
{
    /**
     * @var HttpPipelineArrayCollection $httpPipelinesCollection
     */
    private $httpPipelinesCollection;

    /**
     * @var string
     */
    private $prefix;

    /**
     * Router constructor.
     *
     * @param string $prefix
     */
    public function __construct(string $prefix = '')
    {
        $this->prefix = $prefix;
        $this->httpPipelinesCollection = new HttpPipelineArrayCollection();
    }

    /**
     * Add a 'GET' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function get(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('GET', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'POST' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function post(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('POST', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'PUT' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function put(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('PUT', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'PATCH' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function patch(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('PATCH', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'DELETE' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function delete(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('DELETE', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'OPTIONS' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function options(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('OPTIONS', $this->prefix . $pattern, $stages));
    }

    /**
     * Add a 'HEAD' route to be handled by the application
     *
     * @param string $pattern
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function head(string $pattern, $stages): void
    {
        $this->httpPipelinesCollection->add(new HttpPipeline('HEAD', $this->prefix . $pattern, $stages));
    }

    /**
     * Add multiple verb to a pattern and stages
     *
     * @param string $pattern
     * @param array $verbs
     * @param array|string|callable $stages
     *
     * @return void
     */
    public function map(string $pattern, array $verbs, $stages): void
    {
        foreach ($verbs as $verb) {
            $verb = strtolower($verb);
            $this->$verb($pattern, $stages);
        }
    }

    /**
     * Return all pipelines generated by the router
     *
     * @return HttpPipelineCollectionInterface
     */
    public function pipelines(): HttpPipelineCollectionInterface
    {
        return $this->httpPipelinesCollection;
    }
}